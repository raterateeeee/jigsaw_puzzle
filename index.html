<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>スライドパズル v2.0</title>
<style>
  :root{
    --board-size: 420px;
    --gap: 3px;
    --tile-radius: 10px;
    --anim-ms: 160ms;
    --ink:#1d1d1f; --muted:#666a73; --accent:#1463ff;
  }
  *{box-sizing:border-box}
  html,body{
    height:100%; margin:0; color:var(--ink);
    font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", sans-serif;
    background: radial-gradient(1200px 1200px at 20% -10%, #f8fafc, #eef1f5 60%, #e7ebf0 100%);
  }

  /* 一番上：サイズ切替 */
  .topbar{
    padding:10px 12px 0; display:flex; gap:10px; align-items:center; justify-content:center;
  }
  .seg{display:inline-flex; border:1px solid #0002; border-radius:10px; overflow:hidden; background:#fff}
  .seg button{appearance:none; border:0; padding:8px 10px; background:#0000; cursor:pointer}
  .seg button[aria-pressed="true"]{background:#eef3ff; font-weight:700; color:var(--accent)}

  /* 2段目：サムネ/ステータス */
  header{padding:6px 12px 0; display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:center}
  .thumbs{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  .thumb{
    width:84px; height:56px; border-radius:8px; overflow:hidden; border:2px solid #0000; cursor:pointer;
    box-shadow: inset 0 0 0 1px #0003, 0 1px 2px #0002;
    background-size:cover; background-position:center;
  }
  .thumb.active{border-color:var(--accent)}
  .stat{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .chip{padding:6px 10px; border-radius:999px; background:#fff; border:1px solid #0002}
  .btn{appearance:none; border:1px solid #0003; background:#fff; padding:8px 12px; border-radius:10px; cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .switch{display:inline-flex; gap:6px; align-items:center}
  input[type="checkbox"]{accent-color:var(--accent)}

  main{max-width:980px; margin:10px auto 40px; padding:0 12px; display:grid; grid-template-columns: 1fr auto; gap:14px}
  .preview{width:min(200px, 34vw); aspect-ratio:1; border-radius:12px; overflow:hidden;
           box-shadow: inset 0 0 0 1px #0002, 0 2px 4px #0001; background-size:cover; background-position:center}

  .board-wrap{
    position:relative; width: min(90vw, var(--board-size)); margin-inline:auto;
    /* JSでmargin-topを上乗せして、ポケット分の高さを確保 */
  }
  .board{
    position:relative; width:100%; aspect-ratio:1;
    border-radius:16px; padding:var(--gap);
    background:#ffffffcc; backdrop-filter:saturate(120%) blur(2px);
    box-shadow: inset 0 0 0 1px #0001, 0 8px 20px #0002;
    overflow:visible;
  }
  .grid{
    position:absolute; inset:var(--gap);
    width:calc(100% - var(--gap)*2); height:calc(100% - var(--gap)*2);
    pointer-events:none;
  }
  .grid::before{content:""; position:absolute; inset:0; border-radius:12px; box-shadow:inset 0 0 0 1px #0001; pointer-events:none}

  .tile{
    position:absolute; z-index:2;
    border-radius:var(--tile-radius);
    background-size:100% 100%;
    display:grid; place-items:end; font-weight:700; font-size:clamp(10px,2.4vw,18px);
    color:#fff; text-shadow:0 1px 2px #000, 0 0 4px #000;
    box-shadow:inset 0 0 0 1px #0003, 0 1px 2px #0003;
    transition: transform var(--anim-ms) ease;
    user-select:none; touch-action:manipulation; cursor:pointer;
  }
  .tile.hint::after{ content: attr(data-num); margin:6px; background:#0008; padding:2px 6px; border-radius:6px; font-weight:600; }

  /* 右上の外マス（実マス） */
  .pocket{
    position:absolute; z-index:1;
    width:40px; height:40px; /* JSで上書き */
    border-radius:12px; background:#fff; box-shadow:inset 0 0 0 1px #0002;
    cursor:pointer;
  }

  footer{margin:18px 12px 28px; color:var(--muted); text-align:center; font-size:12px}
  @media (max-width:800px){ main{grid-template-columns: 1fr} }
</style>
</head>
<body>
  <!-- 最上段：サイズ切替 -->
  <div class="topbar">
    <div class="seg" id="sizeSeg" role="tablist" aria-label="サイズ">
      <button role="tab" data-n="3" aria-pressed="false">3×3</button>
      <button role="tab" data-n="4" aria-pressed="true">4×4</button>
      <button role="tab" data-n="5" aria-pressed="false">5×5</button>
    </div>
  </div>

  <!-- 2段目：画像選択とステータス -->
  <header>
    <div class="thumbs" id="thumbs"></div>
    <div class="stat">
      <span class="chip">Moves: <b id="moves">0</b></span>
      <span class="chip">Time: <b id="time">00:00</b></span>
      <button class="btn" id="resetBtn">リセット</button>
      <button class="btn" id="undoBtn">一手戻す</button>
      <label class="switch chip"><input type="checkbox" id="hintChk"> ヒント数字</label>
    </div>
  </header>

  <main>
    <div class="preview" id="preview" title="完成プレビュー"></div>

    <div class="board-wrap" id="boardWrap">
      <div class="board" id="board">
        <div class="grid" id="grid" aria-label="スライドパズル盤"></div>
        <div class="pocket" id="pocket" title="右上の外マス（クリックで出入り）"></div>
      </div>
    </div>
  </main>

  <footer>v2.0 — N×N+1（外マスも実マス）/ 空白は盤内1つ / 右上セル⇄外マスはクリックで出入り（自動で空白を寄せる）/ ボタンは最上段</footer>

<script>
/* 画像3種（picsum 固定ID） */
const IMAGES = [
  { title:"海",   url:"https://picsum.photos/id/1011/800/800" },
  { title:"森",   url:"https://picsum.photos/id/1018/800/800" },
  { title:"都市", url:"https://picsum.photos/id/1031/800/800" }
];

/* 要素・状態 */
const els = {
  thumbs: document.getElementById('thumbs'),
  preview: document.getElementById('preview'),
  sizeSeg: document.getElementById('sizeSeg'),
  moves: document.getElementById('moves'),
  time: document.getElementById('time'),
  resetBtn: document.getElementById('resetBtn'),
  undoBtn: document.getElementById('undoBtn'),
  hintChk: document.getElementById('hintChk'),
  boardWrap: document.getElementById('boardWrap'),
  board: document.getElementById('board'),
  grid: document.getElementById('grid'),
  pocket: document.getElementById('pocket'),
};
let N=4, imgIndex=0, tiles=[], blank=0, moves=0, undoStack=[], hintOn=false;
let timer={id:null,startAt:0,elapsed:0};

/* UI */
function makeThumbs(){
  els.thumbs.innerHTML="";
  IMAGES.forEach((im,i)=>{
    const b=document.createElement('button');
    b.className="thumb"; b.title=im.title;
    b.style.backgroundImage=`url(${im.url})`;
    if(i===imgIndex)b.classList.add('active');
    b.onclick=()=>{imgIndex=i; refreshThumbs(); setPreview(); startNew();};
    els.thumbs.appendChild(b);
  });
}
function refreshThumbs(){[...els.thumbs.children].forEach((c,i)=>c.classList.toggle('active',i===imgIndex));}
function setPreview(){els.preview.style.backgroundImage=`url(${IMAGES[imgIndex].url})`;}
function setupSizeSeg(){
  els.sizeSeg.querySelectorAll('button').forEach(btn=>{
    btn.setAttribute('aria-pressed',btn.dataset.n==N);
    btn.onclick=()=>{N=parseInt(btn.dataset.n,10); buildTiles(); startNew();};
  });
}
function responsiveBoard(){
  const vw=Math.min(window.innerWidth,document.documentElement.clientWidth||9999);
  /* 全体を少し小さく（上限520→480に） */
  document.documentElement.style.setProperty('--board-size',Math.min(480,vw*0.86)+'px');
}
window.addEventListener('resize',responsiveBoard);

/* タイル生成（1..N*N の実ピース。空白は配列の null） */
function buildTiles(){
  document.querySelectorAll('.tile').forEach(n=>n.remove());
  for(let i=1;i<=N*N;i++){
    const d=document.createElement('div');
    d.className='tile'; d.dataset.num=i; d.onclick=()=>onTileClick(i);
    els.board.appendChild(d);
  }
}

/* レイアウト */
function layoutTiles(){
  const gap=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap'))||3;
  const gridRect=els.grid.getBoundingClientRect();
  const boardRect=els.board.getBoundingClientRect();
  const cellW=(gridRect.width-gap*(N-1))/N, cellH=(gridRect.height-gap*(N-1))/N;

  /* 盤の上にポケット分の余白を確保（画面外に出さない） */
  els.boardWrap.style.marginTop = (cellH + gap + 8) + 'px';

  /* ポケット（右上セルの真上） */
  const pIndex=N*N;
  const pocketX=(gridRect.left-boardRect.left)+(N-1)*(cellW+gap);
  const pocketY=(gridRect.top-boardRect.top)-(cellH+gap);
  els.pocket.style.width=`${cellW}px`;
  els.pocket.style.height=`${cellH}px`;
  els.pocket.style.transform=`translate(${pocketX}px,${pocketY}px)`;

  /* タイル配置 */
  document.querySelectorAll('.tile').forEach(d=>{
    const num=parseInt(d.dataset.num,10), pos=tiles.indexOf(num);
    d.style.width=`${cellW}px`; d.style.height=`${cellH}px`;
    d.style.backgroundImage=`url(${IMAGES[imgIndex].url})`;
    d.style.backgroundSize=`${N*100}% ${N*100}%`;
    const want=num-1,bx=(want%N)*(100/(N-1)),by=Math.floor(want/N)*(100/(N-1));
    d.style.backgroundPosition=`${bx}% ${by}%`;
    d.classList.toggle('hint',hintOn);

    if(pos===pIndex){
      d.style.transform=`translate(${pocketX}px,${pocketY}px)`;
    }else{
      const xi=pos%N, yi=Math.floor(pos/N);
      const x=(gridRect.left-boardRect.left)+xi*(cellW+gap);
      const y=(gridRect.top-boardRect.top)+yi*(cellH+gap);
      d.style.transform=`translate(${x}px,${y}px)`;
    }
  });
}

/* 位置・隣接 */
function indexToXY(i){return[i%N,Math.floor(i/N)];}
function xyToIndex(x,y){return y*N+x;}
function neighbors(i){
  const p=N*N;
  if(i===p) return [N-1];                 // ポケットは右上セルと隣接
  const[x,y]=indexToXY(i),nb=[];
  if(x>0)nb.push(xyToIndex(x-1,y));
  if(x<N-1)nb.push(xyToIndex(x+1,y));
  if(y>0)nb.push(xyToIndex(x,y-1));
  if(y<N-1)nb.push(xyToIndex(x,y+1));
  if(i===N-1)nb.push(p);                   // 右上セルはポケットとも隣接
  return nb;
}

/* コア移動（隣接してる時だけ1手で動かす） */
function tryMove(tileNum){
  const pos=tiles.indexOf(tileNum);
  if(pos<0) return false;
  if(neighbors(pos).includes(blank)){
    pushUndo();
    tiles[blank]=tileNum; tiles[pos]=null; blank=pos;
    moves++; els.moves.textContent=moves;
    layoutTiles();
    if(isSolved()) onSolved();
    return true;
  }
  return false;
}

/* クリックの体験を補強：空白を自動で寄せてから出入りさせる */
function onTileClick(tileNum){
  const pos=tiles.indexOf(tileNum), p=N*N, ru=N-1;

  // 通常の一手で動けば終了
  if(tryMove(tileNum)) return;

  // 右上セルのタイル → ポケットへ出したい
  if(pos===ru){
    moveBlankTo(ru, ()=>{ tryMove(tileNum); });
    return;
  }
  // ポケット内のタイル → 右上セルへ入れたい
  if(pos===p){
    moveBlankTo(ru, ()=>{ tryMove(tileNum); });
  }
}

/* ポケット自体をクリックしても同様の出入りを保証 */
els.pocket.onclick = () => {
  const p=N*N, ru=N-1;
  // 空白がポケット：右上セルのタイルをポケットへ
  if(blank===p){ tryMove(tiles[ru]); return; }
  // 空白を右上まで寄せ、その後にポケット⇄右上を実行
  moveBlankTo(ru, ()=>{
    if(blank===ru && tiles[p]!=null) tryMove(tiles[p]);
    else if(blank===p && tiles[ru]!=null) tryMove(tiles[ru]);
  });
};

/* 空白を指定セルまで最短で寄せる（グリッド内だけでBFS） */
function moveBlankTo(targetIndex, done){
  if(blank===targetIndex){ done&&done(); return; }
  const q=[blank], prev=Array(N*N).fill(-1), vis=Array(N*N).fill(false); vis[blank]=true;
  while(q.length){
    const cur=q.shift();
    if(cur===targetIndex) break;
    for(const nb of neighbors(cur)){
      if(nb===N*N) continue; // ポケットは経路に使わない
      if(!vis[nb]){ vis[nb]=true; prev[nb]=cur; q.push(nb); }
    }
  }
  const path=[]; let x=targetIndex; while(x!==-1 && x!==blank){ path.push(x); x=prev[x]; }
  path.reverse();
  const step=()=>{
    if(!path.length){ done&&done(); return; }
    const next=path.shift(); const tileNum=tiles[next];
    if(tileNum!=null) tryMove(tileNum);
    setTimeout(step, 40);
  };
  step();
}

/* クリア：盤内(0..N*N-1)が1..N*Nの順かつ空白＝ポケット */
function isSolved(){
  const p=N*N;
  if(blank!==p) return false;
  for(let i=0;i<N*N;i++) if(tiles[i]!==i+1) return false;
  return true;
}
function onSolved(){
  els.board.animate([{filter:'brightness(1)'},{filter:'brightness(1.15)'},{filter:'brightness(1)'}],{duration:650});
}

/* シャッフル・開始（合法手ランダムウォーク） */
function startNew(){
  const p=N*N;
  tiles=Array.from({length:N*N},(_,i)=>i+1).concat([null]); // N*N+1
  blank=p; // 空白 = ポケットから開始

  let steps=N===3?160:N===4?320:560, prev=-1;
  for(let s=0;s<steps;s++){
    const nbs=neighbors(blank).filter(n=>n!==prev);
    const pick=nbs[(Math.random()*nbs.length)|0];
    tiles[blank]=tiles[pick]; tiles[pick]=null; prev=blank; blank=pick;
  }
  // 初期は必ず盤内に空白を作る（空白がポケットなら右上と入替）
  if(blank===p){ const ru=N-1; tiles[p]=tiles[ru]; tiles[ru]=null; blank=ru; }

  moves=0; els.moves.textContent='0';
  stopTimer(); resetTimer(); startTimer();
  undoStack.length=0; layoutTiles();
}

/* Undo / Timer / キー入力 */
function pushUndo(){undoStack.push({tiles:tiles.slice(),blank,moves,elapsed:timer.elapsed});if(undoStack.length>60)undoStack.shift();}
function undo(){const prev=undoStack.pop();if(!prev)return;tiles=prev.tiles.slice();blank=prev.blank;moves=prev.moves;timer.elapsed=prev.elapsed;els.moves.textContent=moves;renderTime(timer.elapsed);layoutTiles();}
function resetTimer(){timer.elapsed=0;timer.startAt=Date.now();renderTime(0);}
function startTimer(){stopTimer();timer.startAt=Date.now()-timer.elapsed;timer.id=setInterval(()=>{timer.elapsed=Date.now()-timer.startAt;renderTime(timer.elapsed);},250);}
function stopTimer(){if(timer.id){clearInterval(timer.id);timer.id=null;}}
function renderTime(ms){const sec=Math.floor(ms/1000),m=String(Math.floor(sec/60)).padStart(2,'0'),s=String(sec%60).padStart(2,'0');els.time.textContent=`${m}:${s}`;}
document.addEventListener('keydown',e=>{
  const k=e.key,p=N*N; let target=null;
  if(blank===p){ if(k==='ArrowUp'||k==='ArrowRight') target=N-1; }
  else{
    const[bx,by]=indexToXY(blank);
    if(k==='ArrowLeft' && bx<N-1) target=xyToIndex(bx+1,by);
    if(k==='ArrowRight'&& bx>0  ) target=xyToIndex(bx-1,by);
    if(k==='ArrowUp'   && by<N-1) target=xyToIndex(bx,by+1);
    if(k==='ArrowDown' && by>0  ) target=xyToIndex(bx,by-1);
    if(blank===N-1 && (k==='ArrowUp'||k==='ArrowRight')) target=p;
  }
  if(target!=null && tiles[target]!=null){ tryMove(tiles[target]); e.preventDefault(); }
});
els.resetBtn.onclick=()=>startNew();
els.undoBtn.onclick=()=>undo();
els.hintChk.onchange=()=>{hintOn=els.hintChk.checked;layoutTiles();};

/* 起動 */
function init(){
  makeThumbs(); setPreview(); setupSizeSeg(); responsiveBoard(); buildTiles(); startNew();
  new ResizeObserver(()=>layoutTiles()).observe(els.board);
}
init();
</script>
</body>
</html>
